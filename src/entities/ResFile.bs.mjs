// Generated by ReScript, PLEASE EDIT WITH CARE

import * as LintIssue from "./LintIssue.bs.mjs";
import * as ModuleName from "./ModuleName.bs.mjs";
import * as LintContext from "./LintContext.bs.mjs";
import * as Stdlib_Option from "@dzakh/rescript-stdlib/src/Stdlib_Option.bs.mjs";

function make(content, path) {
  return {
          content: content,
          path: path,
          moduleName: Stdlib_Option.getExnWithMessage(ModuleName.fromPath(path), "A ResFile should always have a valid module name.")
        };
}

function normalizeName(name) {
  return name.replace(/\W/g, "").toLowerCase();
}

function lint(resFile, lintContext, prohibitedModuleNames, stdlibModuleName) {
  if (resFile.moduleName === stdlibModuleName || ModuleName.isSubmodule(resFile.moduleName, stdlibModuleName)) {
    var stdlibParentDirName = Stdlib_Option.getExnWithMessage(resFile.path.split("/").at(-2), "A ResFile should always have a directory name");
    if (normalizeName(stdlibModuleName) !== normalizeName(stdlibParentDirName)) {
      return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                      TAG: /* InvalidStdlibParentDirName */4,
                      stdlibParentDirName: stdlibParentDirName
                    }));
    } else {
      return ;
    }
  }
  resFile.content.split("\n").forEach(function (line, idx) {
        prohibitedModuleNames.forEach(function (prohibitedModuleName) {
              var openRe = new RegExp("^ *open " + prohibitedModuleName + "($|\\.)");
              if (openRe.test(line)) {
                return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                                TAG: /* ProhibitedModuleOpen */0,
                                line: idx + 1 | 0,
                                prohibitedModuleName: prohibitedModuleName
                              }));
              }
              var includeRe = new RegExp("^ *include " + prohibitedModuleName + "($|\\.)");
              if (includeRe.test(line)) {
                return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                                TAG: /* ProhibitedModuleInclude */1,
                                line: idx + 1 | 0,
                                prohibitedModuleName: prohibitedModuleName
                              }));
              }
              var assignRe = new RegExp("^ *module.+= " + prohibitedModuleName + "($|\\.)");
              if (assignRe.test(line)) {
                return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                                TAG: /* ProhibitedModuleAssign */2,
                                line: idx + 1 | 0,
                                prohibitedModuleName: prohibitedModuleName
                              }));
              }
              var usageRe = new RegExp("(\\W|^)" + prohibitedModuleName + "\\.");
              if (usageRe.test(line)) {
                return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                                TAG: /* ProhibitedModuleUsage */3,
                                line: idx + 1 | 0,
                                prohibitedModuleName: prohibitedModuleName
                              }));
              }
              
            });
      });
}

function checkIsResFile(dirItem) {
  if (dirItem.endsWith(".res")) {
    return true;
  } else {
    return dirItem.endsWith(".resi");
  }
}

export {
  make ,
  lint ,
  checkIsResFile ,
}
/* No side effect */
