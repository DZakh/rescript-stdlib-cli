// Generated by ReScript, PLEASE EDIT WITH CARE

import * as LintIssue from "./LintIssue.bs.mjs";
import * as ModuleName from "./ModuleName.bs.mjs";
import * as LintContext from "./LintContext.bs.mjs";
import * as Stdlib_Option from "@dzakh/rescript-stdlib/src/Stdlib_Option.bs.mjs";
import * as Stdlib_Result from "@dzakh/rescript-stdlib/src/Stdlib_Result.bs.mjs";

function make(content, path) {
  return {
          content: content,
          path: path,
          moduleName: Stdlib_Option.getExnWithMessage(ModuleName.fromPath(path), "A ResFile should always have a valid module name.")
        };
}

function normalizeName(name) {
  return name.replace(/\W/g, "").toLowerCase();
}

function lint(resFile, lintContext, prohibitedModuleNames, stdlibModuleName, ignoreIssuesBeforeStdlibOpen) {
  if (resFile.moduleName === stdlibModuleName || ModuleName.isSubmodule(resFile.moduleName, stdlibModuleName)) {
    var stdlibParentDirName = Stdlib_Option.getExnWithMessage(resFile.path.split("/").at(-2), "A ResFile should always have a directory name");
    if (normalizeName(stdlibModuleName) !== normalizeName(stdlibParentDirName)) {
      return LintContext.addIssue(lintContext, LintIssue.make(resFile.path, {
                      TAG: /* InvalidStdlibParentDirName */4,
                      stdlibParentDirName: stdlibParentDirName
                    }));
    } else {
      return ;
    }
  }
  var shouldIgnoreLineRef = {
    contents: ignoreIssuesBeforeStdlibOpen
  };
  resFile.content.split("\n").forEach(function (line, idx) {
        var match = shouldIgnoreLineRef.contents;
        if (match) {
          if (ignoreIssuesBeforeStdlibOpen && new RegExp("^open " + stdlibModuleName + "$").test(line)) {
            shouldIgnoreLineRef.contents = false;
            return ;
          } else {
            return ;
          }
        } else {
          prohibitedModuleNames.forEach(function (prohibitedModuleName) {
                var result = Stdlib_Result.flatMap(Stdlib_Result.flatMap(Stdlib_Result.flatMap(new RegExp("^ *open " + prohibitedModuleName + "($|\\.)").test(line) ? ({
                                  TAG: /* Error */1,
                                  _0: LintIssue.make(resFile.path, {
                                        TAG: /* ProhibitedModuleOpen */0,
                                        line: idx + 1 | 0,
                                        prohibitedModuleName: prohibitedModuleName
                                      })
                                }) : ({
                                  TAG: /* Ok */0,
                                  _0: undefined
                                }), (function (param) {
                                if (new RegExp("^ *include " + prohibitedModuleName + "($|\\.)").test(line)) {
                                  return {
                                          TAG: /* Error */1,
                                          _0: LintIssue.make(resFile.path, {
                                                TAG: /* ProhibitedModuleInclude */1,
                                                line: idx + 1 | 0,
                                                prohibitedModuleName: prohibitedModuleName
                                              })
                                        };
                                } else {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: undefined
                                        };
                                }
                              })), (function (param) {
                            if (new RegExp("^ *module.+= " + prohibitedModuleName + "($|\\.)").test(line)) {
                              return {
                                      TAG: /* Error */1,
                                      _0: LintIssue.make(resFile.path, {
                                            TAG: /* ProhibitedModuleAssign */2,
                                            line: idx + 1 | 0,
                                            prohibitedModuleName: prohibitedModuleName
                                          })
                                    };
                            } else {
                              return {
                                      TAG: /* Ok */0,
                                      _0: undefined
                                    };
                            }
                          })), (function (param) {
                        if (new RegExp("(\\W|^)" + prohibitedModuleName + "\\.").test(line)) {
                          return {
                                  TAG: /* Error */1,
                                  _0: LintIssue.make(resFile.path, {
                                        TAG: /* ProhibitedModuleUsage */3,
                                        line: idx + 1 | 0,
                                        prohibitedModuleName: prohibitedModuleName
                                      })
                                };
                        } else {
                          return {
                                  TAG: /* Ok */0,
                                  _0: undefined
                                };
                        }
                      }));
                if (result.TAG === /* Ok */0) {
                  return ;
                } else {
                  return LintContext.addIssue(lintContext, result._0);
                }
              });
          return ;
        }
      });
}

function checkIsResFile(dirItem) {
  if (dirItem.endsWith(".res")) {
    return true;
  } else {
    return dirItem.endsWith(".resi");
  }
}

export {
  make ,
  lint ,
  checkIsResFile ,
}
/* No side effect */
