// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "rescript-struct/src/S.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Process from "process";
import Minimist from "minimist";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_Result from "rescript/lib/es6/belt_Result.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Lib$RescriptStdlibCli from "../Lib.mjs";

function make(runLintCommand, runHelpCommand, runLintHelpCommand) {
  return function () {
    var commandArguments = Process.argv.slice(2);
    var result = Belt_Result.flatMap(Lib$RescriptStdlibCli.Result.mapError(S.parseWith(Minimist(commandArguments), S.union([
                      S.transform(S.$$Object.strict(S.object1([
                                    "_",
                                    S.union([
                                          S.tuple0(),
                                          S.tuple1(S.literalVariant({
                                                    TAG: /* String */0,
                                                    _0: "help"
                                                  }, undefined))
                                        ])
                                  ])), (function (param) {
                              return /* Help */0;
                            }), undefined, undefined),
                      S.transform(S.$$Object.strict(S.object1([
                                    "_",
                                    S.tuple2(S.literalVariant({
                                              TAG: /* String */0,
                                              _0: "help"
                                            }, undefined), S.literalVariant({
                                              TAG: /* String */0,
                                              _0: "lint"
                                            }, undefined))
                                  ])), (function (param) {
                              return /* LintHelp */2;
                            }), undefined, undefined),
                      S.transform(S.$$Object.strict(S.object1([
                                    "_",
                                    S.tuple1(S.literalVariant({
                                              TAG: /* String */0,
                                              _0: "lint"
                                            }, undefined))
                                  ])), (function (param) {
                              return /* Lint */1;
                            }), undefined, undefined)
                    ])), (function (error) {
                var unionErrors = error.code;
                if (typeof unionErrors === "number") {
                  return Js_exn.raiseError("Parsed error always must have the InvalidUnion code");
                }
                if (unionErrors.TAG !== /* InvalidUnion */5) {
                  return Js_exn.raiseError("Parsed error always must have the InvalidUnion code");
                }
                var maybeIllegalOptionName = Belt_Option.map(Caml_option.undefined_to_opt(unionErrors._0.find(function (error) {
                              var match = error.code;
                              if (typeof match === "number" || match.TAG !== /* ExcessField */4) {
                                return false;
                              } else {
                                return true;
                              }
                            })), (function (excessFieldError) {
                        var illegalOptionName = excessFieldError.code;
                        if (typeof illegalOptionName === "number" || illegalOptionName.TAG !== /* ExcessField */4) {
                          return Js_exn.raiseError("The excessFieldError always must have the ExcessField code");
                        } else {
                          return illegalOptionName._0;
                        }
                      }));
                if (maybeIllegalOptionName !== undefined) {
                  return {
                          TAG: /* IllegalOption */0,
                          optionName: maybeIllegalOptionName
                        };
                } else {
                  return /* CommandNotFound */0;
                }
              })), (function (command) {
            switch (command) {
              case /* Help */0 :
                  return {
                          TAG: /* Ok */0,
                          _0: runHelpCommand()
                        };
              case /* Lint */1 :
                  return Lib$RescriptStdlibCli.Result.mapError(runLintCommand(), (function (lintCommandError) {
                                var variant = lintCommandError.NAME;
                                if (variant === "BS_CONFIG_PARSE_FAILURE") {
                                  return {
                                          TAG: /* BsConfigParsingFailure */1,
                                          _0: lintCommandError.VAL
                                        };
                                } else if (variant === "HAS_GLOBALY_OPENED_STDLIB") {
                                  return {
                                          TAG: /* LintErrorHasGlobalyOpenedStdlib */3,
                                          _0: lintCommandError.VAL
                                        };
                                } else {
                                  return {
                                          TAG: /* SourceDirsParsingFailure */2,
                                          _0: lintCommandError.VAL
                                        };
                                }
                              }));
              case /* LintHelp */2 :
                  return {
                          TAG: /* Ok */0,
                          _0: runLintHelpCommand()
                        };
              
            }
          }));
    if (result.TAG === /* Ok */0) {
      return ;
    }
    var error = result._0;
    if (typeof error === "number") {
      console.log("Command not found:", commandArguments.join(" "));
    } else {
      switch (error.TAG | 0) {
        case /* IllegalOption */0 :
            console.log("Illegal option:", error.optionName);
            break;
        case /* BsConfigParsingFailure */1 :
            console.log("Failed to parse \"bsconfig.json\":", error._0);
            break;
        case /* SourceDirsParsingFailure */2 :
            console.log("Failed to parse \".sourcedirs.json\". Check that you use compatible ReScript version. Parsing error:", error._0);
            break;
        case /* LintErrorHasGlobalyOpenedStdlib */3 :
            console.log("Lint failed: Found globally opened module " + error._0 + "");
            break;
        
      }
    }
    Process.exit(1);
  };
}

export {
  make ,
}
/* process Not a pure module */
