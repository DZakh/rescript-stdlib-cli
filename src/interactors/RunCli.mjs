// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Process from "process";
import Minimist from "minimist";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Stdlib_Option from "stdlib/src/Stdlib_Option.mjs";
import * as Stdlib_Result from "stdlib/src/Stdlib_Result.mjs";
import * as S$ReScriptStruct from "rescript-struct/src/S.mjs";

function make(runLintCommand, runHelpCommand, runHelpLintCommand) {
  return function () {
    var commandArguments = Process.argv.slice(2);
    var result = Stdlib_Result.map(Stdlib_Result.mapError(S$ReScriptStruct.parseWith(Minimist(commandArguments), S$ReScriptStruct.union([
                      S$ReScriptStruct.$$Object.strict(S$ReScriptStruct.object(function (o) {
                                S$ReScriptStruct.discriminant(o, "_", S$ReScriptStruct.union([
                                          S$ReScriptStruct.tuple0(),
                                          S$ReScriptStruct.tuple1(S$ReScriptStruct.literalVariant({
                                                    TAG: /* String */0,
                                                    _0: "help"
                                                  }, undefined))
                                        ]));
                                return /* Help */0;
                              })),
                      S$ReScriptStruct.$$Object.strict(S$ReScriptStruct.object(function (o) {
                                S$ReScriptStruct.discriminant(o, "_", S$ReScriptStruct.tuple2(S$ReScriptStruct.literal({
                                              TAG: /* String */0,
                                              _0: "help"
                                            }), S$ReScriptStruct.literal({
                                              TAG: /* String */0,
                                              _0: "lint"
                                            })));
                                return /* LintHelp */2;
                              })),
                      S$ReScriptStruct.$$Object.strict(S$ReScriptStruct.object(function (o) {
                                S$ReScriptStruct.discriminant(o, "_", S$ReScriptStruct.tuple1(S$ReScriptStruct.literal({
                                              TAG: /* String */0,
                                              _0: "lint"
                                            })));
                                return /* Lint */1;
                              }))
                    ])), (function (error) {
                var unionErrors = error.code;
                if (typeof unionErrors === "number") {
                  return Js_exn.raiseError("Parsed error always must have the InvalidUnion code");
                }
                if (unionErrors.TAG !== /* InvalidUnion */5) {
                  return Js_exn.raiseError("Parsed error always must have the InvalidUnion code");
                }
                var maybeIllegalOptionName = Stdlib_Option.map(Caml_option.undefined_to_opt(unionErrors._0.find(function (error) {
                              var match = error.code;
                              if (typeof match === "number" || match.TAG !== /* ExcessField */4) {
                                return false;
                              } else {
                                return true;
                              }
                            })), (function (excessFieldError) {
                        var illegalOptionName = excessFieldError.code;
                        if (typeof illegalOptionName === "number" || illegalOptionName.TAG !== /* ExcessField */4) {
                          return Js_exn.raiseError("The excessFieldError always must have the ExcessField code");
                        } else {
                          return illegalOptionName._0;
                        }
                      }));
                if (maybeIllegalOptionName !== undefined) {
                  return /* IllegalOption */{
                          optionName: maybeIllegalOptionName
                        };
                } else {
                  return /* CommandNotFound */0;
                }
              })), (function (command) {
            switch (command) {
              case /* Help */0 :
                  return runHelpCommand();
              case /* Lint */1 :
                  return runLintCommand(undefined);
              case /* LintHelp */2 :
                  return runHelpLintCommand();
              
            }
          }));
    if (result.TAG === /* Ok */0) {
      return ;
    }
    var error = result._0;
    if (error) {
      console.log("Illegal option:", error.optionName);
    } else {
      console.log("Command not found:", commandArguments.join(" "));
    }
    Process.exit(1);
  };
}

export {
  make ,
}
/* process Not a pure module */
